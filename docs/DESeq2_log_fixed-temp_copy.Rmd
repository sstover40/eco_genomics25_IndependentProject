---
title: "DESeq2_log"
output: html_document
date: "2025-10-14"
---
This is the DESeq for the tonsa F25 reciprocal transplant. Comparing Ambient to OWA.
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#to set our working dir
knitr::opts_knit$set(root.dir = "/gpfs1/cl/ecogen/pbio6800/GroupProjects/tripods/data/recip_trans_GE")
```

Importing libraries:
```{r}
## Import the libraries that we're likely to need in this session

library(DESeq2)
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(ggpubr)
library(vsn)  
library("pheatmap")
library("vsn")

```

Importing the counts matrix, rounding for DESeq2:
```{r}
# Import the counts matrix
countsTable <- read.table("DGE_counts_F1.txt", header=TRUE, row.names=1)
head(countsTable)
dim(countsTable)


countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
head(countsTableRound)
```

Importing the sample description table:
```{r}
#import the sample description table
conds <- read.delim("transplant_exp_metadata_fixed.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)
rownames(conds)
colnames(countsTableRound)
head(conds)
```
Explore patterns in the data - evenness among samples…

```{r}
####################################################
### Explore data distributions
####################################################

# Let's see how many reads we have from each sample
colSums(countsTableRound)
colnames(countsTableRound)

mean(colSums(countsTableRound))

```

Creating a barplot of the number of reads per sample:
```{r}
barplot(colSums(countsTableRound), names.arg=colnames(countsTableRound),cex.names=0.5, las=3,ylim=c(0, 19000000)) #change dims
abline(h=mean(colSums(countsTableRound)), col="blue", lwd=2)
```

```{r}
head(rowSums(countsTableRound))
# average number of counts per transcript
mean(rowSums(countsTableRound))   # 11,930
# median number of counts per gene
median(rowSums(countsTableRound)) # 2,226
```

Bar graph to show the size distribution of the reads:
```{r}
apply(countsTableRound,2,mean) # 2 in the apply function does the action across columns
apply(countsTableRound,1,mean) # 1 in the apply function does the action across rows
hist(apply(countsTableRound,1,mean), xlim=c(0,10000), ylim=c(0,60000),breaks=10000) #breaks is how many different bins you have 

```
Defining our model and creating a DESeq2 object:
```{r}
####################################################

### Start working with DESeq2!

####################################################

#### Create a DESeq object and define the experimental design here with the tilda

dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, 
                              design= ~ treatment)

dim(dds)

# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 12,]
nrow(dds) 

# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression
dds <- DESeq(dds)

# List the results you've generated
resultsNames(dds)
# Copy the results names 
```
Making a PCA plot to visualize gene expression variation among samples:
```{r}
####################################################
### Check the quality of the data by sample clustering and visualization
####################################################

# The goal of transformation "is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low."

# this gives log2(n + 1)
ntd <- normTransform(dds)
meanSdPlot(assay(ntd))

# Variance stabilizing transformation
vsd <- vst(dds, blind=FALSE)
meanSdPlot(assay(vsd))


sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$treatment, vsd$generation, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

# Note any outliers

###############################################################

# PCA to visualize global gene expression patterns

# first transform the data for plotting using variance stabilization
vsd <- vst(dds, blind=FALSE)

pcaData <- plotPCA(vsd, intgroup=c("treatment"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData,"percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=treatment)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()
```
Nicer looking PCA:
```{r}
#points are bigger, added alpha to distinguish generations, switched treatment colors 
ggplot(pcaData, aes(PC1, PC2)) +
  geom_point(size=5, stroke = 1, aes(color=treatment)) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  scale_shape_manual(values=c(21,22,23,24), labels = c("G1", "G2","G3", "G4"))+
  #scale_shape_manual(values=c(21,22,23,24) -> circle, square, diamond, triangle
  scale_fill_manual(values=c('#6699CC',"#CC3333"), labels = c("Control", "Treatment"))+
  scale_alpha_manual(values = c(1.0, 0.8, 0.7, 0.3), guide = "none") +
  theme_bw() +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 3))+
  theme(text = element_text(size = 20)) +
  theme(legend.title = element_blank())

```
Test for differential gene expression using the group model 
```{r}
dds$treatment <- relevel(dds$treatment, ref = "AAAA")
#dds$generation <- relevel(dds$generation, ref = "1")


dds$group <- factor(paste0(dds$treatment))
design(dds) <- ~ group
dds <- DESeq(dds)
resultsNames(dds)
```

```{r}
res_AAHHvAAAA_CvT <- results(dds, contrast=c("group","AAHH","AAAA"), alpha = 0.05) #alpha = significance value
summary(res_AAHHvAAAA_CvT)

# Reordering by significance
res_AAHHvAAAA_CvT <- res_AAHHvAAAA_CvT[order(res_AAHHvAAAA_CvT$padj),]
head(res_AAHHvAAAA_CvT)
```
Plot Individual genes: 
changed the gene name = "TRINITY_DN148010_c1_g22" from the table above 
```{r}
# Counts of specific top interaction gene! (important validatition that the normalization, model is working)
d <-plotCounts(dds, gene="TRINITY_DN148010_c1_g22", intgroup = c("treatment"), returnData=TRUE)
d

plotCounts(dds, gene = "TRINITY_DN148010_c1_g22", intgroup = c("treatment"))


p <- ggplot(d, aes(x = treatment, y = count, color = treatment)) +
  theme_minimal() +
  theme(text = element_text(size=20), panel.grid.major=element_line(colour="grey")) +
  geom_point(position=position_jitter(w=0.2,h=0), size=3) +
  stat_summary(fun = mean, geom = "point", size=5, alpha=0.7)

p

```
Graphing another gene: TRINITY_DN141119_c7_g3 
```{r}
# Counts of specific top interaction gene! (important validatition that the normalization, model is working)
d <-plotCounts(dds, gene="TRINITY_DN141119_c7_g3", intgroup = c("treatment"), returnData=TRUE)
d

plotCounts(dds, gene = "TRINITY_DN141119_c7_g3", intgroup = c("treatment"))


p <- ggplot(d, aes(x = treatment, y = count, color = treatment)) +
  theme_minimal() +
  theme(text = element_text(size=20), panel.grid.major=element_line(colour="grey")) +
  geom_point(position=position_jitter(w=0.2,h=0), size=3) +
  stat_summary(fun = mean, geom = "point", size=5, alpha=0.7)

p

```



We can make an MA plot:
plotMA is actually built into DESeq2

Question: What is the relationship between LFC and magnitude of expression? (blue points are significantly differentially expressed)
```{r}
plotMA(res_AAHHvAAAA_CvT, ylim=c(-10,25))
```


We can make a Volcano plot:

Question: What is the relationship between LFC and significance of DGE?
```{r}

# Make a dataframe
res_df <- as.data.frame(res_AAHHvAAAA_CvT)

# Remove NAs
res_df <- res_df[!is.na(res_AAHHvAAAA_CvT$padj), ]

# Add significance column for color mapping
res_df$significance <- "Not Sig"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange > 0] <- "Up"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange < 0] <- "Down"

#using the new "significance" column to color things 
ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = significance)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("Down" = "red", "Up" = "blue", "Not Sig" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: Generation 1 (Treatment vs Control)",
    x = expression(log[2]~Fold~Change),
    y = expression(-log[10]~Adjusted~p~value)
  ) +
  theme_bw(base_size = 16) +
  theme(legend.title = element_blank())
```
Heatmap of top 20 genes sorted by pvalue

Question: For DEGs, what does gene expression variation look like across individual samples among treatment groups?
```{r}
topgenes <- head(rownames(resG1_CvT),100)
mat <- assay(vsd)[topgenes,]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(dds)[,c("generation","line")])
pheatmap(mat, annotation_col=df)
pheatmap(mat, annotation_col=df, cluster_cols = F) #dont cluster by columns 
```
Let’s make plots to explore differentially expressed genes between CvsT across generations

First step: Identify the DEGs in the contrast for control versus treatment for each generation
```{r}

#Gen1
resG1_CvT <- results(dds, contrast=c("group","controlG1","treatmentG1"), alpha = 0.05)
resG1_CvT <- resG1_CvT[order(resG1_CvT$padj),] #sort
head(resG1_CvT)
summary(resG1_CvT)

resG1_CvT <- resG1_CvT[!is.na(resG1_CvT$padj),]
degs_G1_CvTM <- row.names(resG1_CvT[resG1_CvT$padj < 0.05,])

#Gen2
resG2_CvT <- results(dds, contrast=c("group","controlG2","treatmentG2"), alpha = 0.05)
resG2_CvT <- resG2_CvT[order(resG2_CvT$padj),] #sort
head(resG2_CvT)
summary(resG2_CvT)

resG2_CvT <- resG2_CvT[!is.na(resG2_CvT$padj),]
degs_G2_CvTM <- row.names(resG2_CvT[resG2_CvT$padj < 0.05,])

#Gen3
resG3_CvT <- results(dds, contrast=c("group","controlG3","treatmentG3"), alpha = 0.05)
resG3_CvT <- resG3_CvT[order(resG3_CvT$padj),] #sort
head(resG3_CvT)
summary(resG3_CvT)

resG3_CvT <- resG3_CvT[!is.na(resG3_CvT$padj),]
degs_G3_CvTM <- row.names(resG3_CvT[resG3_CvT$padj < 0.05,])

#Gen4
resG4_CvT <- results(dds, contrast=c("group","controlG4","treatmentG4"), alpha = 0.05)
resG4_CvT <- resG4_CvT[order(resG4_CvT$padj),] #sort
head(resG4_CvT)
summary(resG4_CvT)

resG4_CvT <- resG4_CvT[!is.na(resG4_CvT$padj),]
degs_G4_CvTM <- row.names(resG4_CvT[resG4_CvT$padj < 0.05,])
```
Make a heatmap of G1 sig genes and how they change across generations

Question: How does gene expression change across generations for the genes that are initially differentially expressed in Generation 1 (between different developmental temperatures, 18 vs. 22 C)
```{r}
sig_genes_G1 <- rownames(resG1_CvT[which(resG1_CvT$padj < 0.05 & !is.na(resG1_CvT$padj)), ])

# Combine into a data frame
lfc_mat <- data.frame(
  Gen1 = resG1_CvT[sig_genes_G1, "log2FoldChange"],
  Gen2 = resG2_CvT[sig_genes_G1, "log2FoldChange"],
  Gen3 = resG3_CvT[sig_genes_G1, "log2FoldChange"],
  Gen4 = resG4_CvT[sig_genes_G1, "log2FoldChange"]
)

# Remove any rows with missing values (some genes may not be in all result tables, will mess with values)
lfc_mat <- na.omit(lfc_mat)

pheatmap(lfc_mat,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC (Treatment vs Control) of Sig Genes in Gen 1")

```
Sorting by Euclidean distance means that it will not cluster by treatment but it will cluster by how similar things are. Similar things will be much closer together.

There is a massive flip flop between generation one and generation 2, oscillation continues in gen3 and gen4 but less strong. Maybe can look at the same analysis but at DEG at each generation going on to see if we can see a similar pattern of occillation

Doing the same for the next generations: 
```{r}
sig_genes_G2 <- rownames(resG2_CvT[which(resG2_CvT$padj < 0.05 & !is.na(resG2_CvT$padj)), ])

# Combine into a data frame
lfc_mat <- data.frame(
  Gen1 = resG1_CvT[sig_genes_G2, "log2FoldChange"],
  Gen2 = resG2_CvT[sig_genes_G2, "log2FoldChange"],
  Gen3 = resG3_CvT[sig_genes_G2, "log2FoldChange"],
  Gen4 = resG4_CvT[sig_genes_G2, "log2FoldChange"]
)

# Remove any rows with missing values (some genes may not be in all result tables, will mess with values)
lfc_mat <- na.omit(lfc_mat)

pheatmap(lfc_mat,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC (Treatment vs Control) of Sig Genes in Gen 2")


```
 
Here we can make a Venn or Euler plot

Question: How much overlap is there between genes differentially expressed between treatments across generations?
only comparing 1-3 bc gen4 is very similar to gen3 

```{r}
library(eulerr)

# Total
length(degs_G1_CvTM)  #573 
length(degs_G2_CvTM)  #4568  
length(degs_G3_CvTM)  #1234 
length(degs_G4_CvTM)  #48 

# Intersections
length(intersect(degs_G1_CvTM,degs_G2_CvTM))  #227
length(intersect(degs_G1_CvTM,degs_G3_CvTM))  #71
#length(intersect(degs_G1_CvTM,degs_G4_CvTM)) 

length(intersect(degs_G2_CvTM,degs_G3_CvTM))  #294
#length(intersect(degs_G2_CvTM,degs_G4_CvTM))  

#length(intersect(degs_G3_CvTM,degs_G4_CvTM)) 

# To calc number shared in all three contrasts
int12 <- intersect(degs_G1_CvTM,degs_G2_CvTM) 
length(intersect(degs_G3_CvTM,int12))  #13 genes significant across all contrasts 

# Number unique in each gen
573 - 227 - 71 + 13 #  G1 288
4568 - 227 - 294 + 13 #  G2 4060
1234 - 71 - 294 + 13 #  G3 882

227 - 13 # G1&G2 214
71 - 13 # G1&G3 58
294 - 13 # G2&G3 281

# Note that the names are important and have to be specific to line up the diagram
fit1 <- euler(c("G1" = 288, "G2" = 4060 , "G3" = 882, "G1&G2" = 214, "G1&G3" = 58, "G2&G3" = 281, "G1&G2&G3" = 13))

plot(fit1,  lty = 1:3, quantities = TRUE)
# lty changes the lines

plot(fit1, quantities = TRUE, fill = "transparent",
     lty = 1:3,
     labels = list(font = 4))

#cross check
 #  total G1
 #  total G2
 #  total G3
```
Can make a scatterplot comparing LFC of shared DEG between generation

```{r}

# Combine into a data frame
lfc_mat <- data.frame(
  Gen1 = resG1_CvT[sig_genes_G2, "log2FoldChange"],
  Gen2 = resG2_CvT[sig_genes_G2, "log2FoldChange"],
  Gen3 = resG3_CvT[sig_genes_G2, "log2FoldChange"],
  Gen4 = resG4_CvT[sig_genes_G2, "log2FoldChange"]
)

#making a df of only overlapping DEGs between G1 and G2 (should have 227 rows)

G1G2_overlap <- intersect(degs_G1_CvTM,degs_G2_CvTM)


```

Importing the data from DESeq2 to generate the results that we need for testing functional enrichment
```{r}
## Import the libraries that we're likely to need in this session

library(DESeq2)
library(dplyr)
library(tibble)
library(topGO)
library(GO.db)
library(ggplot2)
library(scales) 
 
# Import the counts matrix
countsTable <- read.table("counts_matrix.txt", header=TRUE, row.names=1)
dim(countsTable)

countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
# Corrects the column names to match between the metadata table and the counts matrix.
colnames(countsTableRound) <- substr(colnames(countsTableRound), start=1, stop = 4)

#import the sample description table
conds <- read.delim("metadata.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)


#### Create a DESeq object and define the experimental design here with the tilda

dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, 
                              design= ~ generation + line)

dim(dds)

# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 
# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression

dds$line <- relevel(dds$line, ref = "control")
dds$generation <- relevel(dds$generation, ref = "G1")

dds$group <- factor(paste0(dds$line, dds$generation))
design(dds) <- ~ group
dds <- DESeq(dds)
resultsNames(dds)


#Gen1
resG1_CvT <- results(dds, contrast=c("group","controlG1","treatmentG1"), alpha = 0.05)
resG1_CvT <- resG1_CvT[order(resG1_CvT$padj),] #sort
resG1_CvT <- resG1_CvT[!is.na(resG1_CvT$padj),]

#Gen2
resG2_CvT <- results(dds, contrast=c("group","controlG2","treatmentG2"), alpha = 0.05)
resG2_CvT <- resG2_CvT[order(resG2_CvT$padj),] #sort
resG2_CvT <- resG2_CvT[!is.na(resG2_CvT$padj),]

#Gen3
resG3_CvT <- results(dds, contrast=c("group","controlG3","treatmentG3"), alpha = 0.05)
resG3_CvT <- resG3_CvT[order(resG3_CvT$padj),] #sort
resG3_CvT <- resG3_CvT[!is.na(resG3_CvT$padj),]

#Gen4
resG4_CvT <- results(dds, contrast=c("group","controlG4","treatmentG4"), alpha = 0.05)
resG4_CvT <- resG4_CvT[order(resG4_CvT$padj),] #sort
resG4_CvT <- resG4_CvT[!is.na(resG4_CvT$padj),]
```

Before we jump in, what do the distributions of our results look like? looking at the results tables since they are ultimately going into the functional enrichment analysis 
```{r}
library(ggplot2)
library(ggpubr)

# Convert results to data frame and clean
res_df <- as.data.frame(resG1_CvT)
res_df <- res_df[!is.na(res_df$padj), ]

# Calculate and add -log10(padj)
res_df$negLog10Padj <- -log10(res_df$padj)

# Panel 1: padj distribution
p1 <- ggplot(res_df, aes(x = padj)) +
  geom_histogram(bins = 50, fill = "skyblue3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("Adjusted p-values (padj)") +
  xlab("padj") +
  ylab("Count")

# Panel 2: -log10(padj)
p2 <- ggplot(res_df, aes(x = negLog10Padj)) +
  geom_histogram(bins = 50, fill = "tomato3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("-log10(padj)") +
  xlab("-log10(padj)") +
  ylab("Count")

# Panel 3: Wald Statistic
p3 <- ggplot(res_df, aes(x = stat)) +
  geom_histogram(bins = 50, fill = "seagreen3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("Wald Statistic") +
  xlab("stat") +
  ylab("Count")

# Combine vertically with ggpubr
combined_plot <- ggarrange(
  p1, p2, p3,
  ncol = 1, nrow = 3,
  labels = c("A", "B", "C"),  # optional panel labels
  align = "v",                # vertical alignment
  common.legend = FALSE
)

# Show combined plot
combined_plot
```

And what are the relationships between these metrics?
```{r}
# Panel D: Wald statistic vs -log10(padj) scatter 
p4 <- ggplot(res_df, aes(x = pvalue, y = negLog10Padj)) +
  geom_point(alpha = 0.4, color = "yellow4") + ylim(c(0,5)) +
  theme_minimal(base_size = 8) +
  ggtitle("P-value vs -log10(padj)") +
  xlab("P-value") +
  ylab("-log10(padj)") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")

# Panel E: Wald statistic vs -log10(padj) scatter 
p5 <- ggplot(res_df, aes(x = stat, y = negLog10Padj)) +
  geom_point(alpha = 0.4, color = "purple4") + ylim(c(0,5)) +
  theme_minimal(base_size = 8) +
  ggtitle("Wald Statistic vs -log10(padj)") +
  xlab("Wald statistic") +
  ylab("-log10(padj)") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")


combined_plot <- ggarrange(
  p4, p5,
  ncol = 2, nrow = 1,
  align = "h"
)

# Show combined plot
combined_plot
```

Let’s make a density plot with a rugplot below to understand what we’re testing in a functional enrichment test.
The rug plot can tell us how many genes are driving that tail distributions that are driving the density plot tail 
This is another way to look at the data that is in the plot above.
```{r}
ggplot(res_df, aes(x = negLog10Padj)) +
  geom_density(fill = "lightblue", color = "blue", alpha = 0.5, linewidth = 1) + xlim(c(0,5)) +
  geom_rug(sides = "b", color = "gray30", alpha = 0.5) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed", color = "red") +
  theme_minimal(base_size = 8) +
  xlab(expression(-log[10](padj))) +
  ylab("Density") +
  ggtitle(expression("Density of " * -log[10](padj)))
```

Run TopGO!

You’ll need the Genes_GO_terms_output.tsv file that maps each gene to GO categories for the transcriptome of our species. This can be found in: /gpfs1/cl/ecogen/pbio6800/Transcriptomics/enrichment. You can cp it to your /mydata directory.
Let’s start with DESeq2 results object for Gen 2, since we know it has the most differentially expressed genes
```{r}
library(topGO)
library(GO.db)

# Convert to data frame
res_G2_df <- as.data.frame(resG2_CvT)

# Add geneID column from rownames
res_G2_df$geneID <- rownames(res_G2_df)
res_G2_df <- res_G2_df[, c("geneID", setdiff(names(res_G2_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G2_GO <- res_G2_df[res_G2_df$geneID %in% tonsa_go$geneID, ]

# Identify significant DEGs 
res_G2_GO_sig <- subset(res_G2_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
tonsa_stat <- merge(res_G2_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G2 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,    #this is the minimum GO category size. can play with this
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen2")
topGO_plot
```

How about for Generation 1?!

Can you run the same analysis for generation 1? Can you make a figure of two side-by-side plots for Gen 1 and Gen 2? How about all four contrasts?
Can we output the enrichment results from TopGO and try REViGO like what was used in the paper we discuss in class today.
```{r}
# Select only the columns REVIGO needs
revigo_input <- filtered_GO_results[, c("GO.ID", "classicFisher")] #this table will be used to filter 

sigRes <- revigo_input[as.numeric(revigo_input$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes, file = "topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```



